<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Emotion Reading Task</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- SurveyJS (CDN) -->
  <link rel="stylesheet" href="https://unpkg.com/survey-core@1.10.0/modern.min.css">
  <script src="https://unpkg.com/survey-core@1.10.0/survey.core.min.js"></script>
  <script src="https://unpkg.com/survey-jquery@1.10.0/survey.jquery.min.js"></script>
  <!-- You need HTTPS for mic access. GitHub Pages provides that. -->
  <style> body{max-width:800px;margin:24px auto;padding:0 16px;} .rec{margin:8px 0;} </style>
</head>
<body>
  <h2>Emotion Reading Task</h2>
  <div id="surveyContainer"></div>

  <script type="module">
    const API = "https://script.google.com/macros/s/AKfycbwq970N9tIv10WxcmU-CQCHxWexIQRDfUTHbtYynhuglic3jYB4BnLK8Lz2h2fwe6Si/exec"; // ends with /exec
    const qs = new URLSearchParams(location.search);
    const PROLIFIC_PID = qs.get("PROLIFIC_PID") || crypto.randomUUID(); // fallback for local testing

    async function getAssignment() {
      const r = await fetch(`${API}?PROLIFIC_PID=${encodeURIComponent(PROLIFIC_PID)}`);
      if (!r.ok) throw new Error("Assignment API error");
      return r.json(); // { participant_id, lines: {happy:..., sad:...} }
    }

    // Simple in-page recorder using MediaRecorder ‚Üí Base64
    function recorderUI(emotion) {
      const id = `rec_${emotion}`;
      return {
        type: "html",
        name: id,
        html: `
          <div class="rec" data-emotion="${emotion}">
            <button type="button" id="${id}_btn">üé§ Start</button>
            <span id="${id}_status"></span><br>
            <audio id="${id}_player" controls></audio>
            <input type="hidden" id="${id}_data">
          </div>
          <script>
          (function(){
            const btn = document.getElementById("${id}_btn");
            const status = document.getElementById("${id}_status");
            const player = document.getElementById("${id}_player");
            const hidden = document.getElementById("${id}_data");
            let rec, chunks=[], stream;

            btn.onclick = async () => {
              if (!rec || rec.state === "inactive") {
                try {
                  stream = await navigator.mediaDevices.getUserMedia({audio:true});
                  rec = new MediaRecorder(stream);
                  chunks = [];
                  rec.ondataavailable = e => chunks.push(e.data);
                  rec.onstop = async () => {
                    const blob = new Blob(chunks, { type: rec.mimeType || "audio/webm" });
                    player.src = URL.createObjectURL(blob);
                    const buf = await blob.arrayBuffer();
                    const b64 = btoa(String.fromCharCode(...new Uint8Array(buf)));
                    hidden.value = JSON.stringify({ base64: b64, mimeType: blob.type || "audio/webm" });
                    status.textContent = " Recorded ‚úì";
                    if (stream) stream.getTracks().forEach(t=>t.stop());
                  };
                  rec.start();
                  btn.textContent = "‚èπ Stop";
                  status.textContent = " Recording‚Ä¶";
                } catch (err) {
                  alert("Microphone blocked. Please allow mic access.");
                }
              } else if (rec.state === "recording") {
                rec.stop();
                btn.textContent = "üé§ Re-record";
              }
            };
          })();
          </script>
        `
      };
    }

    (async () => {
      const assign = await getAssignment();
      const elements = [
        { type:"html", html:`<p><b>Participant ID:</b> ${assign.participant_id}</p>` },
      ];

      // Build one block per emotion (line text + recorder)
      for (const [emotion, line] of Object.entries(assign.lines)) {
        elements.push(
          { type:"html", html:`<h3>${emotion.toUpperCase()}</h3><p>${line || "(no text found)"}<p>` },
          recorderUI(emotion)
        );
      }

      // Hidden fields we want to store
      elements.push(
        { type:"text", name:"participant_id", defaultValue:String(assign.participant_id), visible:false },
        { type:"text", name:"prolific_pid", defaultValue:String(PROLIFIC_PID), visible:false }
      );

      const surveyJSON = {
        showProgressBar: "top",
        pages: [{ elements }]
      };

      const survey = new Survey.Model(surveyJSON);
      Survey.StylesManager.applyTheme("modern");
      document.getElementById("surveyContainer").Survey({ model: survey });

      // On complete: upload each recording to Apps Script
      survey.onComplete.add(async s => {
        const data = s.data; // contains hidden fields only; audio is in DOM
        const pid = data.participant_id;

        // Grab each hidden <input id="rec_EMOTION_data"> and POST it
        const uploadPromises = [];
        for (const emotion of Object.keys(assign.lines)) {
          const el = document.getElementById(`rec_${emotion}_data`);
          if (!el || !el.value) { continue; }
          const { base64, mimeType } = JSON.parse(el.value);
          uploadPromises.push(fetch(API, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ participant_id: pid, emotion, base64, mimeType })
          }).then(r => r.json()));
        }

        try {
          await Promise.all(uploadPromises);
          // Redirect to Prolific completion
          location.href = "https://app.prolific.com/submissions/complete?cc=YOUR_COMPLETION_CODE";
        } catch (e) {
          alert("Upload failed. Please contact us with your PID: "+pid);
          console.error(e);
        }
      });
    })();
  </script>
</body>
</html>
