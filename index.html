<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Emotion Reading Task</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/survey-core@1.10.0/modern.min.css">
  <script src="https://unpkg.com/survey-core@1.10.0/survey.core.min.js"></script>
  <script src="https://unpkg.com/survey-jquery@1.10.0/survey.jquery.min.js"></script>
  <style>
    body{max-width:800px;margin:24px auto;padding:0 16px;}
    .rec{margin:8px 0;}
    .rec button{margin-right:8px;}
  </style>
</head>
<body>
  <h2>Emotion Reading Task</h2>
  <div id="surveyContainer"></div>

  <script type="module">
    const API = "https://script.google.com/macros/s/AKfycbwq970N9tIv10WxcmU-CQCHxWexIQRDfUTHbtYynhuglic3jYB4BnLK8Lz2h2fwe6Si/exec";

    // ---- assignment (token-based) ----
    async function getAssignment() {
      const saved = localStorage.getItem("survey_token") || "";
      const url = saved ? `${API}?token=${encodeURIComponent(saved)}` : API;
      const r = await fetch(url);
      if (!r.ok) throw new Error("Assignment API error");
      const data = await r.json();
      if (data.token && data.token !== saved) localStorage.setItem("survey_token", data.token);
      return data; // { token, participant_id, lines:{...} }
    }

    // ---- build survey ----
    const assign = await getAssignment();

    const elements = [
      { type:"html", html:`<p><b>Participant ID:</b> ${assign.participant_id}</p>` }
    ];

    // create one HTML block per emotion with recorder UI (NO <script> tags here)
    for (const [emotion, line] of Object.entries(assign.lines)) {
      const id = `rec_${emotion}`;
      elements.push(
        { type:"html", name:id+"_text", html:`<h3>${emotion.toUpperCase()}</h3><p>${line || "(no text found)"}<p>` },
        {
          type:"html",
          name:id,
          html: `
            <div class="rec" data-emotion="${emotion}">
              <button type="button" id="${id}_btn">🎤 Start</button>
              <span id="${id}_status"></span><br>
              <audio id="${id}_player" controls></audio>
              <input type="hidden" id="${id}_data">
            </div>
          `
        }
      );
    }

    // hidden fields
    elements.push(
      { type:"text", name:"participant_id", defaultValue:String(assign.participant_id), visible:false }
    );

    const surveyJSON = { showProgressBar:"top", pages:[{ elements }] };
    const survey = new Survey.Model(surveyJSON);
    Survey.StylesManager.applyTheme("modern");
    document.getElementById("surveyContainer").Survey({ model: survey });

    // ---- attach recorder logic after SurveyJS renders each HTML question ----
    survey.onAfterRenderQuestion.add((_, options) => {
      const el = options.htmlElement;
      const qname = options.question.name;
      if (!qname.startsWith("rec_")) return;

      const emotion = el.querySelector(".rec")?.dataset?.emotion;
      if (!emotion) return;

      const btn    = el.querySelector(`#${qname}_btn`);
      const status = el.querySelector(`#${qname}_status`);
      const player = el.querySelector(`#${qname}_player`);
      const hidden = el.querySelector(`#${qname}_data`);

      let rec, chunks=[], stream;

      btn.onclick = async () => {
        if (!rec || rec.state === "inactive") {
          try {
            stream = await navigator.mediaDevices.getUserMedia({audio:true});
            rec = new MediaRecorder(stream);
            chunks = [];
            rec.ondataavailable = e => chunks.push(e.data);
            rec.onstop = async () => {
              const blob = new Blob(chunks, { type: rec.mimeType || "audio/webm" });
              player.src = URL.createObjectURL(blob);
              const buf = await blob.arrayBuffer();
              const b64 = btoa(String.fromCharCode(...new Uint8Array(buf)));
              hidden.value = JSON.stringify({ base64: b64, mimeType: blob.type || "audio/webm" });
              status.textContent = " Recorded ✓";
              if (stream) stream.getTracks().forEach(t=>t.stop());
            };
            rec.start();
            btn.textContent = "⏹ Stop";
            status.textContent = " Recording…";
          } catch (err) {
            alert("Microphone blocked. Please allow mic access.");
          }
        } else if (rec.state === "recording") {
          rec.stop();
          btn.textContent = "🎤 Re-record";
        }
      };
    });

    // ---- submit: upload each recording to Apps Script ----
    survey.onComplete.add(async s => {
      const pid = s.data.participant_id;
      const uploadPromises = [];

      for (const emotion of Object.keys(assign.lines)) {
        const hidden = document.getElementById(`rec_${emotion}_data`);
        if (!hidden || !hidden.value) continue;
        const { base64, mimeType } = JSON.parse(hidden.value);
        uploadPromises.push(
          fetch(API, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ participant_id: pid, emotion, base64, mimeType })
          }).then(r => r.json())
        );
      }

      try {
        await Promise.all(uploadPromises);
        // simple thank-you page
        document.body.innerHTML = `<h2>Thanks!</h2><p>Your recordings were uploaded. PID: <b>${pid}</b></p>`;
      } catch (e) {
        alert("Upload failed. Please contact us with your PID: "+pid);
        console.error(e);
      }
    });
  </script>
</body>
</html>
